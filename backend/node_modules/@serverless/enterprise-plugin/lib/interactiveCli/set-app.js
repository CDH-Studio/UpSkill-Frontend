'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const _ = require('lodash');

const _require = require('@serverless/platform-sdk'),
      createApp = _require.createApp,
      createAccessKeyForTenant = _require.createAccessKeyForTenant,
      createDeployProfile = _require.createDeployProfile,
      getApps = _require.getApps,
      getDeployProfiles = _require.getDeployProfiles,
      getLoggedInUser = _require.getLoggedInUser,
      listTenants = _require.listTenants,
      refreshToken = _require.refreshToken,
      setDefaultDeploymentProfile = _require.setDefaultDeploymentProfile,
      writeConfigFile = _require.writeConfigFile;

const enableConfirm = require('./enableConfirm');

const writeTenantAndApp = require('./writeTenantAndApp');

const isValidAppName = RegExp.prototype.test.bind(/^[a-z0-9](?:[a-z0-9-]{0,126}[a-z0-9])?$/);

const tenantsChoice =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* (inquirer, tenantNames) {
    return (yield inquirer.prompt({
      message: 'What org do you want to add this to?',
      type: 'list',
      name: 'tenantName',
      choices: Array.from(tenantNames)
    })).tenantName;
  });

  return function tenantsChoice(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

const deployProfileChoice =
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(function* (inquirer, deployProfiles) {
    return (yield inquirer.prompt({
      message: 'What deployment profile do you want to use?',
      type: 'list',
      name: 'deploymentProfile',
      choices: Array.from(deployProfiles)
    })).deploymentProfile;
  });

  return function deployProfileChoice(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

const appNameChoice =
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(function* (inquirer, appNames) {
    return (yield inquirer.prompt({
      message: 'What application do you want to add this to?',
      type: 'list',
      name: 'appName',
      choices: Array.from(appNames).concat({
        name: '[create a new app]',
        value: '_create_'
      })
    })).appName;
  });

  return function appNameChoice(_x5, _x6) {
    return _ref3.apply(this, arguments);
  };
}();

const appNameInput =
/*#__PURE__*/
function () {
  var _ref4 = _asyncToGenerator(function* (inquirer, appNames) {
    return (yield inquirer.prompt({
      message: 'What do you want to name this application?',
      type: 'input',
      name: 'appName',
      validate: input => {
        input = input.trim();

        if (!isValidAppName(input)) {
          return 'App name is not valid.\n' + '   - It should only contain lowercase alphanumeric and hyphens.\n' + '   - It should start and end with an alphanumeric character.\n' + "   - Shouldn't exceed 128 characters";
        }

        if (appNames.includes(input)) return 'App of this name already exists';
        return true;
      }
    })).appName.trim();
  });

  return function appNameInput(_x7, _x8) {
    return _ref4.apply(this, arguments);
  };
}();

module.exports = {
  check(serverless) {
    return _asyncToGenerator(function* () {
      if (!serverless.config.servicePath) return false;
      if (serverless.service.provider.name !== 'aws') return false;
      if (serverless.service.tenant && serverless.service.app) return false;
      let user = getLoggedInUser();
      let tenants = new Set();

      if (!user) {
        return false;
      } else if (!user.idToken) {
        for (var _i = 0, _Object$keys = Object.keys(user.accessKeys); _i < _Object$keys.length; _i++) {
          const tenant = _Object$keys[_i];
          tenants.add(tenant);
        }
      } else {
        yield refreshToken();
        user = getLoggedInUser();
        tenants = new Set((yield listTenants({
          username: user.username,
          idToken: user.idToken
        })).map(tenant => tenant.tenantName));
      }

      if (!tenants.size) return false;
      return {
        user,
        tenants
      };
    })();
  },

  run(serverless, {
    user,
    tenants
  }) {
    return _asyncToGenerator(function* () {
      const inquirer = serverless.interactiveCli.inquirer;

      if (!serverless.service.tenant) {
        if (!(yield enableConfirm(inquirer))) return null;
      }

      const tenantName = yield _asyncToGenerator(function* () {
        if (tenants.size === 1) return tenants.values().next().value;

        if (serverless.service.tenant && tenants.has(serverless.service.tenant)) {
          return serverless.service.tenant;
        }

        return tenantsChoice(inquirer, tenants);
      })();
      let token;

      if (user.accessKeys && user.accessKeys[tenantName]) {
        token = user.accessKeys[tenantName];
      } else {
        token = yield createAccessKeyForTenant(tenantName);
        yield writeConfigFile({
          users: {
            [user.userId]: {
              dashboard: {
                accessKeys: {
                  [tenantName]: token
                }
              }
            }
          }
        });
      }

      const apps = yield getApps({
        tenant: tenantName,
        token
      });
      let appName;
      const appNames = apps.map(app => app.appName);

      if (serverless.service.app && appNames.includes(serverless.service.app)) {
        appName = serverless.service.app;
      } else {
        appName = apps.length ? yield appNameChoice(inquirer, appNames) : '_create_';
      }

      if (appName === '_create_') {
        const newAppName = yield appNameInput(inquirer, appNames);

        var _ref6 = yield createApp({
          tenant: tenantName,
          app: newAppName,
          token
        });

        appName = _ref6.appName;
        let deployProfiles = yield getDeployProfiles({
          tenant: tenantName,
          accessKey: token
        });
        let deploymentProfile;

        if (deployProfiles.length === 0) {
          yield createDeployProfile({
            name: 'default',
            tenant: tenantName,
            accessKey: token
          });
          deployProfiles = yield getDeployProfiles({
            tenant: tenantName
          });
        }

        if (deployProfiles.length === 1) {
          deploymentProfile = deployProfiles[0].deploymentProfileUid;
        } else {
          deploymentProfile = yield deployProfileChoice(inquirer, deployProfiles.map(({
            name
          }) => name));
          deploymentProfile = _.find(deployProfiles, ({
            name
          }) => name === deploymentProfile).deploymentProfileUid;
        }

        yield setDefaultDeploymentProfile({
          accessKey: token,
          app: appName,
          tenant: tenantName,
          deploymentProfile
        });
      }

      return writeTenantAndApp(serverless, tenantName, appName);
    })();
  }

};
//# sourceMappingURL=set-app.js.map